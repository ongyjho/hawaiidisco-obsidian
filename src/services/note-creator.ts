import { App, TFile, normalizePath } from "obsidian";
import { Article, Digest, HawaiiDiscoSettings } from "../types";
import { escapeYaml, formatDate, sanitizeFeedName, slugify } from "../utils";

export class NoteCreator {
	constructor(
		private app: App,
		private settings: HawaiiDiscoSettings,
	) {}

	updateSettings(settings: HawaiiDiscoSettings): void {
		this.settings = settings;
	}

	async createOrOpenArticleNote(
		article: Article,
		bookmarkTags?: string[],
		memo?: string | null,
	): Promise<string | null> {
		const filePath = this.articleFilePath(article);
		await this.ensureFolder(this.articleFolderPath(article));

		const existing = this.app.vault.getAbstractFileByPath(filePath);
		if (existing instanceof TFile) {
			return filePath;
		}

		const frontmatter = this.buildArticleFrontmatter(
			article,
			bookmarkTags,
		);
		const body = this.buildArticleBody(article, memo);
		const content = frontmatter + "\n\n" + body;

		await this.app.vault.create(filePath, content);
		return filePath;
	}

	async createDigestNote(digest: {
		content: string;
		article_count: number;
		period_days: number;
	}): Promise<string> {
		const folderPath = normalizePath(
			`${this.settings.notesFolder}/digests`,
		);
		await this.ensureFolder(folderPath);

		const dateStr = new Date().toISOString().slice(0, 10);
		const filePath = normalizePath(
			`${folderPath}/${dateStr}_weekly_digest.md`,
		);

		const prefix = this.settings.tagsPrefix;
		const frontmatter = [
			"---",
			`title: "Weekly Digest ${dateStr}"`,
			`date: ${dateStr}`,
			`period_days: ${digest.period_days}`,
			`article_count: ${digest.article_count}`,
			"tags:",
			`  - ${prefix}`,
			`  - ${prefix}/digest`,
			"created_by: hawaiidisco",
			"---",
		].join("\n");

		const body = [
			`# Weekly Digest (${dateStr})`,
			"",
			`*${digest.article_count} articles from the past ${digest.period_days} days*`,
			"",
			digest.content,
			"",
			"---",
			`*Generated by Hawaii Disco on ${dateStr}*`,
		].join("\n");

		const fullContent = frontmatter + "\n\n" + body;

		const existing = this.app.vault.getAbstractFileByPath(filePath);
		if (existing instanceof TFile) {
			await this.app.vault.modify(existing, fullContent);
		} else {
			await this.app.vault.create(filePath, fullContent);
		}
		return filePath;
	}

	private buildArticleFrontmatter(
		article: Article,
		tags?: string[],
	): string {
		const dateStr = formatDate(article.published_at ?? article.fetched_at);
		const prefix = this.settings.tagsPrefix;

		const fmTags = [
			prefix,
			`${prefix}/${sanitizeFeedName(article.feed_name)}`,
		];
		if (tags) {
			for (const t of tags) {
				fmTags.push(`${prefix}/${t}`);
			}
		}

		return [
			"---",
			`title: "${escapeYaml(article.title)}"`,
			`source: ${article.link}`,
			`feed: ${article.feed_name}`,
			`date: ${dateStr}`,
			"tags:",
			...fmTags.map((t) => `  - ${t}`),
			"created_by: hawaiidisco",
			"---",
		].join("\n");
	}

	private buildArticleBody(
		article: Article,
		memo?: string | null,
	): string {
		const lines: string[] = [];

		lines.push(`# ${article.title}`, "");
		lines.push("## Summary", "");
		lines.push(article.description ?? "*(No summary available)*", "");

		if (this.settings.includeInsight && article.insight) {
			lines.push("## AI Insight", "", article.insight, "");
		}

		if (this.settings.includeTranslation) {
			const hasTranslation =
				article.translated_title ||
				article.translated_desc ||
				article.translated_body;
			if (hasTranslation) {
				lines.push("## Translation", "");
				if (article.translated_title) {
					lines.push(
						`**Title**: ${article.translated_title}`,
						"",
					);
				}
				if (article.translated_desc) {
					lines.push(
						`**Description**: ${article.translated_desc}`,
						"",
					);
				}
				if (article.translated_body) {
					lines.push(article.translated_body, "");
				}
			}
		}

		lines.push("## My Notes", "");
		lines.push(memo ?? "*(No notes yet)*", "");

		const nowStr = new Date().toISOString().slice(0, 10);
		lines.push("---");
		lines.push(`*Saved from Hawaii Disco on ${nowStr}*`);
		lines.push(`*Original: [${article.title}](${article.link})*`);

		return lines.join("\n");
	}

	private articleFolderPath(article: Article): string {
		const feedDir = sanitizeFeedName(article.feed_name);
		return normalizePath(`${this.settings.notesFolder}/${feedDir}`);
	}

	private articleFilePath(article: Article): string {
		const dateStr = formatDate(article.published_at ?? article.fetched_at);
		const slug = slugify(article.title);
		const feedDir = sanitizeFeedName(article.feed_name);
		return normalizePath(
			`${this.settings.notesFolder}/${feedDir}/${dateStr}_${slug}.md`,
		);
	}

	private async ensureFolder(path: string): Promise<void> {
		const existing = this.app.vault.getAbstractFileByPath(path);
		if (!existing) {
			await this.app.vault.createFolder(path);
		}
	}
}
